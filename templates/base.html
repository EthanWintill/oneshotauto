<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Body Work Quote Tracker{% endblock %}</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-dark': '#2c3e50',
                        'primary-dark-hover': '#34495e',
                        'primary-blue': '#3498db',
                        'primary-blue-hover': '#2980b9',
                        'light-gray': '#ecf0f1',
                        'light-gray-alt': '#f8f9fa',
                        'border-gray': '#ddd',
                        'border-gray-dark': '#bdc3c7',
                        'success-bg': '#d4edda',
                        'success-text': '#155724',
                        'error-bg': '#f8d7da',
                        'error-text': '#721c24',
                        'danger': '#e74c3c',
                        'danger-hover': '#c0392b',
                    },
                    fontFamily: {
                        'sans': ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    {% block extra_css %}{% endblock %}
</head>
<body class="bg-gray-100 text-gray-800 font-sans m-0 p-0">
    <nav class="bg-primary-dark text-white py-4 px-8 shadow-md flex items-center">
        <h1 class="inline-block mr-8">Body Work Quote Tracker</h1>
        <a href="{{ url_for('index') }}" class="text-white no-underline mr-6 px-4 py-2 rounded transition-colors hover:bg-primary-dark-hover">All Quotes</a>
        <a href="{{ url_for('create_quote') }}" class="text-white no-underline mr-6 px-4 py-2 rounded transition-colors hover:bg-primary-dark-hover">New Quote</a>

        <div class="flex-1"></div>

        {% if is_xero_connected() %}
            <a href="{{ url_for('xero_test') }}" class="text-white hover:text-gray-200 no-underline transition flex items-center gap-2 mr-4">
                <span class="bg-green-500 w-2 h-2 rounded-full"></span>
                Xero Connected
            </a>
            <a href="{{ url_for('xero_disconnect') }}" class="text-white hover:text-gray-200 no-underline transition text-sm">
                Disconnect
            </a>
        {% else %}
            <a href="{{ url_for('xero_authorize') }}" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md no-underline transition font-medium">
                Connect to Xero
            </a>
        {% endif %}
    </nav>

    <div class="max-w-[1400px] mx-auto px-8 py-6">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <div class="my-4">
                    {% for category, message in messages %}
                        <div class="p-4 rounded mb-2 {% if category == 'success' %}bg-success-bg text-success-text border border-green-300{% else %}bg-error-bg text-error-text border border-red-300{% endif %}">
                            {{ message }}
                        </div>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}

        {% block content %}{% endblock %}
    </div>

    {% block extra_js %}{% endblock %}

    <script>
        // Image compression function
        async function compressImage(file, maxWidth = 1600, quality = 0.8) {
            // If file is already very small, skip
            try {
                if (file.size < 100 * 1024) return file; // <100KB skip
                // try createImageBitmap path (faster)
                const bitmap = await createImageBitmap(file);
                const ratio = Math.min(1, maxWidth / bitmap.width);
                const width = Math.round(bitmap.width * ratio);
                const height = Math.round(bitmap.height * ratio);
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(bitmap, 0, 0, width, height);
                return await new Promise((resolve) => {
                    canvas.toBlob((blob) => {
                        if (!blob) return resolve(file);
                        // If compressed blob is bigger than original, keep original
                        if (blob.size >= file.size) return resolve(file);
                        const newName = file.name.replace(/\.[^.]+$/, '.jpg');
                        const newFile = new File([blob], newName, { type: blob.type || 'image/jpeg' });
                        resolve(newFile);
                    }, 'image/jpeg', quality);
                });
            } catch (e) {
                // Fallback using Image element (older browsers or decoding failure)
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            const ratio = Math.min(1, maxWidth / img.width);
                            const width = Math.round(img.width * ratio);
                            const height = Math.round(img.height * ratio);
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            canvas.toBlob((blob) => {
                                if (!blob) return resolve(file);
                                if (blob.size >= file.size) return resolve(file);
                                const newName = file.name.replace(/\.[^.]+$/, '.jpg');
                                const newFile = new File([blob], newName, { type: blob.type || 'image/jpeg' });
                                resolve(newFile);
                            }, 'image/jpeg', quality);
                        } catch (err) {
                            resolve(file);
                        }
                    };
                    img.onerror = () => resolve(file);
                    img.src = URL.createObjectURL(file);
                });
            }
        }

        // Handle picture inputs when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.picture-input').forEach((input) => {
                input.addEventListener('change', async function() {
                    const file = input.files[0];
                    if (!file) return;

                    // Find the row (for table layouts) or closest container
                    const row = input.closest('tr') || input.closest('div');
                    const preview = row ? row.querySelector('.picture-preview') : null;
                    const urlInput = row ? row.querySelector('.picture-url') : document.querySelector(`#${input.dataset.urlInputId}`);

                    if (!urlInput) {
                        console.error('Could not find URL input for picture');
                        return;
                    }

                    // Compress image client-side before upload
                    let uploadFile = file;
                    try {
                        uploadFile = await compressImage(file, 1600, 0.8);
                    } catch (e) {
                        uploadFile = file;
                    }

                    // Upload to backend
                    const formData = new FormData();
                    formData.append('file', uploadFile, uploadFile.name);

                    try {
                        const resp = await fetch('/upload-picture', { method: 'POST', body: formData });
                        if (resp.ok) {
                            const data = await resp.json();
                            urlInput.value = data.url;
                            if (preview) {
                                preview.src = data.url;
                                preview.style.display = 'inline-block';
                            }
                        } else {
                            const error = await resp.json();
                            alert('Failed to upload image: ' + (error.error || 'Unknown error'));
                        }
                    } catch (error) {
                        alert('Failed to upload image: ' + error.message);
                    }
                });
            });
        });
    </script>
</body>
</html>
